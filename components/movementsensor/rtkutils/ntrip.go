// Package rtkutils implements necessary functions to set and return
// NTRIP information here.
package rtkutils

import (
	"bufio"
	"fmt"
	"io"
	"log"
	"strconv"
	"strings"

	"github.com/de-bkg/gognss/pkg/ntrip"

	"go.viam.com/rdk/logging"
)

// NtripInfo contains the information necessary to connect to a mountpoint.
type NtripInfo struct {
	URL                string
	Username           string
	Password           string
	MountPoint         string
	Client             *ntrip.Client
	Stream             io.ReadCloser
	MaxConnectAttempts int
}

// NtripConfig is used for converting attributes for a correction source.
type NtripConfig struct {
	NtripURL             string `json:"ntrip_url"`
	NtripConnectAttempts int    `json:"ntrip_connect_attempts,omitempty"`
	NtripMountpoint      string `json:"ntrip_mountpoint,omitempty"`
	NtripPass            string `json:"ntrip_password,omitempty"`
	NtripUser            string `json:"ntrip_username,omitempty"`
}

// Sourcetable struct contains the stream.
type Sourcetable struct {
	Streams []Stream
}

// Stream contrains a stream record in sourcetable.
// https://software.rtcm-ntrip.org/wiki/STR
type Stream struct {
	MP             string   // Datastream mountpoint
	Identifier     string   // Source identifier (most time nearest city)
	Format         string   // Data format (https://software.rtcm-ntrip.org/wiki/STR#DataFormats)
	FormatDetails  string   // Specifics of data format (https://software.rtcm-ntrip.org/wiki/STR#DataFormats)
	Carrier        int      // Phase information (https://software.rtcm-ntrip.org/wiki/STR#Carrier)
	NavSystem      []string // Navigation System (https://software.rtcm-ntrip.org/wiki/STR#NavigationSystem)
	Network        string   // Network name (https://software.rtcm-ntrip.org/wiki/NET)
	Country        string   // ISO 3166 country code (https://en.wikipedia.org/wiki/ISO_3166-1)
	Latitude       float32  // Position, Latitude in degree
	Longitude      float32  // Position, Longitude in degree
	Nmea           bool     // Caster requires NMEA input (1) or not (0)
	Solution       int      // Generated by single base (0) or network (1)
	Generator      string   // Generating soft- or hardware
	Compression    string   // Compression algorithm
	Authentication string   // Access protection for data streams None (N), Basic (B) or Digest (D)
	Fee            bool     // User fee for data access: yes (Y) or no (N)
	BitRate        int      // Datarate in bits per second
	Misc           string   // Miscellaneous information
}

// NewNtripInfo function validates and sets NtripConfig arributes and returns NtripInfo.
func NewNtripInfo(cfg *NtripConfig, logger logging.Logger) (*NtripInfo, error) {
	n := &NtripInfo{}

	// Init NtripInfo from attributes
	n.URL = cfg.NtripURL
	if n.URL == "" {
		return nil, fmt.Errorf("NTRIP expected non-empty string for %q", cfg.NtripURL)
	}
	n.Username = cfg.NtripUser
	if n.Username == "" {
		logger.Info("ntrip_username set to empty")
	}
	n.Password = cfg.NtripPass
	if n.Password == "" {
		logger.Info("ntrip_password set to empty")
	}
	n.MountPoint = cfg.NtripMountpoint
	if n.MountPoint == "" {
		logger.Info("ntrip_mountpoint set to empty")
	}
	n.MaxConnectAttempts = cfg.NtripConnectAttempts
	if n.MaxConnectAttempts == 10 {
		logger.Info("ntrip_connect_attempts using default 10")
	}

	logger.Debug("Returning n")
	return n, nil
}

// ParseSourcetable gets the sourcetable and parses it.
func (n *NtripInfo) ParseSourcetable() (*Sourcetable, error) {
	reader, err := n.Client.GetSourcetable()
	if err != nil {
		return nil, err
	}
	defer func() {
		if err := reader.Close(); err != nil {
			log.Println("Error closing reader:", err)
		}
	}()

	st := &Sourcetable{}
	st.Streams = make([]Stream, 0, 200)
	scanner := bufio.NewScanner(reader)
	ln := ""

Loop:
	for scanner.Scan() {
		ln := scanner.Text()
		if strings.HasPrefix(ln, "#") || strings.HasPrefix(ln, "*") { // comment
			continue
		}
		fields := strings.Split(ln, ";")
		switch fields[0] {
		case "CAS":
			continue
		case "NET":
			continue
		case "STR":
			if str, err := ParseStream(ln); err == nil {
				st.Streams = append(st.Streams, str)
			}
		case "ENDSOURCETABLE":
			break Loop
		default:
			return nil, fmt.Errorf("%s: illegal sourcetable line: '%s'", n.URL, ln)
		}
	}

	if ln != "ENDSOURCETABLE" {
		return nil, fmt.Errorf("invalid sourcetable: missing string \"ENDSOURCETABLE\" in %s", ln)
	}

	return st, nil
}

// ParseStream parses a line from the sourcetable.
func ParseStream(line string) (Stream, error) {
	fields := strings.Split(line, ";")

	if len(fields) < 19 {
		return Stream{}, fmt.Errorf("missing fields at stream line: %s", line)
	}

	carrier, err := strconv.Atoi(fields[5])
	if err != nil {
		return Stream{}, fmt.Errorf("parsing the streams carrier in line: %s", line)
	}

	satSystems := strings.Split(fields[6], "+")

	lat, err := strconv.ParseFloat(fields[9], 32)
	if err != nil {
		return Stream{}, fmt.Errorf("parsing the streams latitude in line: %s", line)
	}
	lon, err := strconv.ParseFloat(fields[10], 32)
	if err != nil {
		return Stream{}, fmt.Errorf("parsing the streams longitude in line: %s", line)
	}

	nmea, err := strconv.ParseBool(fields[11])
	if err != nil {
		return Stream{}, fmt.Errorf("parsing the streams nmea in line: %s", line)
	}

	sol, err := strconv.Atoi(fields[12])
	if err != nil {
		return Stream{}, fmt.Errorf("parsing the streams solution in line: %s", line)
	}

	fee := false
	if fields[4] == "Y" {
		fee = true
	}

	bitrate, err := strconv.Atoi(fields[17])
	if err != nil {
		bitrate = 0
	}

	return Stream{
		MP: fields[1], Identifier: fields[2], Format: fields[3], FormatDetails: fields[4],
		Carrier: carrier, NavSystem: satSystems, Network: fields[7], Country: fields[8],
		Latitude: float32(lat), Longitude: float32(lon), Nmea: nmea, Solution: sol, Generator: fields[13],
		Compression: fields[14], Authentication: fields[15], Fee: fee, BitRate: bitrate, Misc: fields[18],
	}, nil
}

// HasStream checks if the sourcetable contains the given mountpoint it's stream.
func (st *Sourcetable) HasStream(mountpoint string) (Stream, bool) {
	for _, str := range st.Streams {
		if str.MP == mountpoint {
			return str, true
		}
	}

	return Stream{}, false
}
